* 25  Объектно-ориентированный Лисп

В этой главе мы поговорим об объектно-ориентированном программировании
в Лиспе.  В Common Lisp включён набор операторов для написания
объектно-ориентированных программ.  Совместно они называются Объектная
система Common Lisp (CLOS).  Здесь мы будем рассматривать CLOS не как
способ написания объектно-ориентированных программ, но как особую
программу на Лиспе.  Это ключ к пониманию отношения между Лиспом и
объектно-ориентированным программированием.

* 25.1  Plus ça change (Сколько ни меняй)

# Plus ça change, plus c'est la même chose.
# Сколько ни меняй - всё одно и то же.
# Чем больше всё меняется, тем больше всё остаётся по-старому.
# Полная цитата, с указанием авторства Альфонса Карра, используется
# эпиграфом к третьей главе SICP; в русском издании без перевода.

Объектно-ориентированное программирование — иной способ организации
программ.  Эта перемена аналогична той, которая имела место в
перераспределении вычислительной мощности.  В 1970 году
многопользовательской компьютерной системой считались один-два больших
мейнфрейма, соединённых с большим числом примитивных терминалов.
Сейчас же это — скорее большое число рабочих станций, соединённых
между собой сетью.  Вычислительная мощность системы теперь
распределена среди индивидуальных пользователей, а не сконцентрирована
в одном большом компьютере.

Объектно-ориентированное программирование отлично от традиционного, в
общем то, так же: вместо одной программы, работающей с инертной массой
данных, самим данным указывают, как себя вести, и программа содержится
неявно во взаимодействиях между этими новыми «объектами» данных.

Пусть, например, мы пишем программу расчёта площадей двумерных фигур.
Один из способов — написать единственную функцию, различающую тип
своего аргумента и работающую соответственно:

#+BEGIN_SRC lisp
(defun area (x)
  (cond ((rectangle-p x) (* (height x) (width x)))
        ((circle-p x) (* pi (expt (radius x) 2)))))
#+END_SRC

Согласно объектно-ориентированному подходу же каждый объект сам может
подсчитать свою площадь.  Функция =area= разделяется на части, каждое
выражение распространяется на свой класс объектов; метод =area= класса
=rectangle= может быть
: #'(lambda (x) (* (height x) (width x)))
а класса =circle=
: #'(lambda (x) (* pi (expt (radius x) 2)))
В такой модели у объекта спрашивают о его площади, и он отвечает
сообразно методу своего класса.

Рождение CLOS могло бы показаться знаком того, что Лисп меняется,
вступая на путь объектно-ориентированной парадигмы.  На самом деле
правильнее сказать, что Лисп, вступая на него, остаётся тем же.  Но
принципы, лежащие в основе Лиспа, не имеют названия, а
объектно-ориентированное программирование имеет, оттого и наблюдается
новая тенденция характеризовать Лисп как объектно-ориентированный.
Правильнее сказать, что Лисп - расширяемый язык, допускающий лёгкую
реализацию концепции объектно-ориентированного программирования.

Поскольку CLOS уже написана, называние Лиспа объектно-ориентированным
не ложно.  Однако такой взгляд слишком ограничен.  Да, Лисп -
объектно-ориентированный язык, но не потому, что он перенял
объектно-ориентированную модель.  Наоборот, сама модель оказывается
лишь ещё одной метаморфозой лежащих в основе Лиспа абстракций.
Доказательством этому служит CLOS, написанная на Лиспе программа,
делающая Лисп объектно-ориентированным.

Эта глава нацелена выявить связь между Лиспом и
объектно-ориентированным программированием, изучая CLOS как пример
встроенного языка.  Это также и хороший способ понять саму CLOS: в
конце концов, ничто не объясняет отличительную черту языка лучше, чем
набросок её реализации.  В разделе 7.6 так были объяснены макросы.
Подобный набросок построения объектно-ориентированных абстракций на
Лиспе дан в следующем разделе.  Он предоставляет исходную точку
описания CLOS в разделах 25.3-25.6.

* 25.2  Объекты в простом Лиспе

Из Лиспа можно сформировать много разнообразных языках.  И есть
особенно простое соответствие между идеями объектно-ориентированного
программирования и фундаментальными абстракциями Лиспа.  Правда,
размеры CLOS затемняют этот факт.  Поэтому до рассмотрения того, что
можно сделать с CLOS, разберёмся с простым Лиспом.

Большая часть желаемого от объектно-ориентированного программирования
в Лиспе есть и так.  Для оставшейся достаточно удивительно мало кода.
В этом разделе на двух страницах будет определена объектная система,
достаточная для многих настоящих приложений.  Объектно-ориентированное
программирование по меньшей мере включает объекты,
1) обладающие свойствами,
2) отвечающие на сообщения
3) и наследующие свойства и методы от своих родителей.

В Лиспе коллекции свойств можно хранить разными способами.  Один -
представлять объекты в виде хэш-таблиц.  Доступ к отдельным свойствам
предоставляет =gethash=:
: (gethash 'color obj)
Поскольку функции сами — объекты данных, их тоже можно хранить в
качестве свойств.  Это обеспечивает методы; вызов метода объекта есть
вызов одноимённого свойства:
: (funcall (gethash 'move obj) obj 10)
На основе этой идеи можно ввести синтаксис передачи сообщений в стиле
Smalltalk:
: (defun tell (obj message &rest args)
:   (apply (gethash message obj) obj args))
так, что сказать объекту передвинуться на 10 можно так:
: (tell obj 'move 10)

На самом деле единственное, чего не хватает в простом Лиспе - это
наследование, элементарный вариант которого можно написать в шести
строках кода, определив рекурсивную версию =gethash=:

#+BEGIN_SRC lisp
(defun rget (obj prop)
  (multiple-value-bind (val win) (gethash prop obj)
    (if win
        (values val win)
        (let ((par (gethash 'parent obj)))
          (and par (rget par prop))))))
#+END_SRC

Одной лишь замены =gethash= на =rget= достаточно для наследования
свойств и методов.  Родительский объект задаётся так:
: (setf (gethash 'parent obj) obj2)
Пока что у нас лишь единичное наследование - у объекта может быть
только один родитель.  Но чтобы получить множественное наследование,
достаточно представить свойство =parent= в виде списка и определить
=rget= как на рисунке 25.1.

#+SRCNAME: Рисунок 25.1: Множественное наследование
#+BEGIN_SRC lisp
(defun rget (obj prop)
  (some2 #'(lambda (a) (gethash prop a))
         (get-ancestors obj)))

(defun get-ancestors (obj)
  (labels ((getall (x)
             (append (list x)
                     (mapcan #'getall
                             (gethash 'parents x)))))
    (stable-sort (delete-duplicates (getall obj))
                 #'(lambda (x y)
                     (member y (gethash 'parents x))))))

(defun some2 (fn lst)
  (if (atom lst)
      nil
      (multiple-value-bind (val win) (funcall fn (car lst))
        (if (or val win)
            (values val win)
            (some2 fn (cdr lst))))))
#+END_SRC

С единичным наследованием мы просто рекурсивно искали свойство объекта
по цепочке наследования.  Когда объект не знал о свойстве, мы
обращались к его родителю, и так далее.  Со множественным
наследованием мы хотим того же, но дело усложняется тем, что предки
формируют граф, а не простой список.  Нельзя искать в нём в глубину:
при наличии нескольких родителей может статься, как на рисунке 25.2,
что =a= происходит от =b= и =c=, которые оба происходят от =d=.  Обход
в глубину (или, скорее, в высоту) рассмотрит =a=, =b=, =d=, =c=, =d=.
Если желаемое свойство содержится и в =d=, и в =c=, будет получено
значение из =d=, а не из =c=.  Это нарушит принцип, согласно которому
производные классы замещают значения по-умолчанию их родителей.

#+CAPTION: Рисунок 25.2: Множественность путей к надклассу
#+BEGIN_EXAMPLE
   d
  / \
 *   *
b     c
 \   /
  * *
   a
#+END_EXAMPLE

Согласно обыкновенной идее наследования, ни к одному объекту не
следует обращаться до его наследников.  В данном случае, правильный
порядок поиска - =a=, =b=, =c=, =d=.  Как это обеспечить?  Проще всего
построить список предков исходного объекта, отсортировать его так,
чтобы никакой объект не предшествовал наследникам, и наконец проверить
его элементы по порядку.

Данная стратегия используется =get-ancestors=, возвращающей правильно
отсортированный список из объекта и его предков.  Для сортировки
=get-ancestors= вызывает =stable-sort=, а не =sort=, чтобы не
нарушить порядок параллельных предков.  Как только список
отсортирован, =rget= просто находит первый объект с искомым
свойством.  (Вспомогательная функция =some2= представляет собой
вариант =some= для использования в таких функциях как =gethash=,
сообщающих об успехе или неудаче вторым возвращаемым значением.)

Список предков объектов начинается наиболее специфичными и кончается
наименее специфичными: если =orange= — потомок =citrus=, который
потомок =fruit=, то список будет =(orange citrus fruit)=.

Когда у объекта несколько родителей, порядок их следования - слева
направо.  То есть если выполнить
: (setf (gethash 'parents x) (list y z))
то =y= будет рассмотрена до =z= при обращении к наследуемому
свойству.  Например, можно задать, что патриотичный подлец во-первых -
подлец, а патриот - во-вторых:

#+BEGIN_SRC lisp
> (setq scoundrel (make-hash-table)
        patriot (make-hash-table)
        patriotic-scoundrel (make-hash-table))
#<Hash-Table C4219E>
> (setf (gethash 'serves scoundrel) 'self
        (gethash 'serves patrior)   'country
        (gethash 'parents patriotic-scoundrel)
                 (list scoundrel patriot))
(#<Hash-Table C41C7E> #<Hash-Table C41F0E>)
> (rget patriotic-scoundrel 'serves)
SELF
T
#+END_SRC

Улучшим немного этот набросок системы.  Можно начать с функции
создания объектов.  Она должна будет строить список предков объекта в
момент его создания.  Имеющийся код перестраивает их при всяком
запросе, но нет причин не делать этого заранее.  Функция =obj= на
рисунке 25.3 создаёт новый объект и сортирует список предков.  Для
использования последнего переопределена =rget=.

#+SRCNAME: Рисунок 25.3: Функция создания объектов
#+BEGIN_SRC lisp
(defun obj (&rest parents)
  (let ((obj (make-hash-table)))
    (setf (gethash 'parents obj) parents)
    (ancestors obj)
    obj))

(defun ancestors (obj)
  (or (gethash 'ancestors obj)
      (setf (gethash 'ancestors obj) (get-ancestors obj))))

(defun rget (obj prop)
  (some2 #'(lambda (a) (gethash prop a))
           (ancestors obj)))
#+END_SRC

Ещё можно улучшить синтаксис передачи сообщений.  Сама =tell= - лишнее
нагромождение; поскольку глаголы приходиться писать вторыми, программы
больше нельзя читать как обычные префиксные выражения Лиспа:
: (tell (tell obj 'find-owner) 'find-owner)

#+SRCNAME: Рисунок 25.4: Функциональный синтаксис
#+BEGIN_SRC lisp
(defmacro defprop (name &optional meth?)
  `(progn
     (defun ,name (obj &rest args)
       ,(if meth?
            `(run-methods obj ',name args)
             `(rget obj ',name)))
     (defsetf ,name (obj) (val)
       `(setf (gethash ',',name ,obj) ,val))))

(defun run-methods (obj name args)
  (let ((meth (rget obj name)))
    (if meth
        (apply meth obj args)
        (error "No ~A method for ~A." name obj))))
#+END_SRC

Можно устранить =tell=, определяя функции с именами свойств, как на
рисунке 25.4.  Необязательный аргумент =meth?= означает, что
определяемое свойство есть метод.  Иначе он - просто слот, и
возвращает результат =rget=.  Определив имя любого свойства, скажем,
: (defprop find-owner t)
можно обращаться к нему вызовом функции, так что код снова читается
как Лисп:
: (find-owner (find-owner obj))
И прошлый пример упрощается:

#+BEGIN_SRC lisp
> (progn
    (setq scoundrel (obj))
    (setq patriot (obj))
    (setq patriotic-scoundrel (obj scoundrel patriot))
    (defprop serves)
    (setf (serves scoundrel) 'self)
    (setf (serves patriot) 'country)
    (serves patriotic-scoundrel))
SELF
T
#+END_SRC

В текущей реализации объект может иметь только один метод с заданным
именем.  Этот метод либо собственный, либо унаследованный.  Удобной
была бы большая гибкость, позволяющая комбинировать локальные и
унаследованные методы.  Например, метод =move= некоторого объекта
может вызвать =move= родителя, дополнительно выполнив что-либо до или
после.

Чтобы сделать это возможным, добавим к нашей программе методы -до,
-после и -вокруг.  Методы-до позволят писать «Но сначала исполни это».
Они вызываются, начиная с наиболее специфичного, как вступление к
остальным методам.  Методы-после позволят писать «P. S.  Исполни это.»
Они вызываются, начиная с наименее специфичного, как эпилог вызова.
Между ними исполняется собственно метод, называемый теперь /главным
методом/.  Именно его результат возвращается, даже если за ним следуют
методы-после.

Методы -до и -после позволяют обернуть новое поведение вокруг главного
метода.  Методы-вокруг предоставляют более радикальный способ делать
то же.  Если имеется метод-вокруг, он будет вызван /вместо/ главного
метода.  Затем, по своему усмотрению, он может сам вызвать главный
метод (с помощью /call-next/ на рисунке 25.7).

#+SRCNAME Рисунок 25.5: Вспомогательные методы
#+BEGIN_SRC lisp
(defstruct meth
  around before primary after)

(defmacro meth- (field obj)
  (let ((gobj (gensym)))
    `(let ((,gobj ,obj))
       (and (meth-p ,gobj)
            (,(symb 'meth- field) ,gobj)))))

(defun run-methods (obj name args)
  (let ((pri (rget obj name :primary)))
    (if pri
        (let ((ar (rget obj name :around)))
          (if ar
              (apply ar obj args)
              (run-core-methods obj name args pri)))
        (error "No primary ~A method for ~A." name obj))))

(defun run-core-methods (obj name args &optional pri)
  (multiple-value-prog1
      (progn (run-befores obj name args)
             (apply (or pri (rget obj name :primary))
                    obj args))
    (run-afters obj name args)))

(defun rget (obj prop &optional meth (skip 0))
  (some2 #'(lambda (a)
             (multiple-value-bind (val win) (gethash prop a)
               (if win
                   (case meth (:around (meth- around val))
                         (:primary (meth- primary val))
                         (t (values val win))))))
           (nthcdr skip (ancestors obj))))
#+END_SRC

#+SRCNAME: Рисунок 25.6: Вспомогательные методы (продолжение)
#+BEGIN_SRC lisp
(defun run-befores (obj prop args)
  (dolist (a (ancestors obj))
    (let ((bm (meth- before (gethash prop a))))
      (if bm (apply bm obj args)))))

(defun run-afters (obj prop args)
  (labels ((rec (lst)
             (when lst
               (rec (cdr lst))
               (let ((am (meth- after
                                (gethash prop (car lst)))))
                 (if am (apply am (car lst) args))))))
    (rec (ancestors obj))))
#+END_SRC
