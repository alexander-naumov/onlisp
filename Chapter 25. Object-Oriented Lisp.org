* 25  Объектно-ориентированный Лисп

В этой главе мы поговорим об объектно-ориентированном программировании
в Лиспе.  В Common Lisp включён набор операторов для написания
объектно-ориентированных программ.  Совместно они называются Объектная
система Common Lisp (CLOS).  Здесь мы будем рассматривать CLOS не как
способ написания объектно-ориентированных программ, но как особую
программу на Лиспе.  Это ключ к пониманию отношения между Лиспом и
объектно-ориентированным программированием.

* 25.1  Plus ça change (Сколько ни меняй)

# Plus ça change, plus c'est la même chose.
# Сколько ни меняй - всё одно и то же.
# Чем больше всё меняется, тем больше всё остаётся по-старому.
# Полная цитата, с указанием авторства Альфонса Карра, используется
# эпиграфом к третьей главе SICP; в русском издании без перевода.

Объектно-ориентированное программирование — иной способ организации
программ.  Эта перемена аналогична той, которая имела место в
перераспределении вычислительной мощности.  В 1970 году
многопользовательской компьютерной системой считались один-два больших
мейнфрейма, соединённых с большим числом примитивных терминалов.
Сейчас же это — скорее большое число рабочих станций, соединённых
между собой сетью.  Вычислительная мощность системы теперь
распределена среди индивидуальных пользователей, а не сконцентрирована
в одном большом компьютере.

Объектно-ориентированное программирование отлично от традиционного, в
общем то, так же: вместо одной программы, работающей с инертной массой
данных, самим данным указывают, как себя вести, и программа содержится
неявно во взаимодействиях между этими новыми «объектами» данных.

Пусть, например, мы пишем программу расчёта площадей двумерных фигур.
Один из способов — написать единственную функцию, различающую тип
своего аргумента и работающую соответственно:

#+BEGIN_SRC lisp
(defun area (x)
  (cond ((rectangle-p x) (* (height x) (width x)))
        ((circle-p x) (* pi (expt (radius x) 2)))))
#+END_SRC

Согласно объектно-ориентированному подходу же каждый объект сам может
подсчитать свою площадь.  Функция =area= разделяется на части, каждое
выражение распространяется на свой класс объектов; метод =area= класса
=rectangle= может быть
: #'(lambda (x) (* (height x) (width x)))
а класса =circle=
: #'(lambda (x) (* pi (expt (radius x) 2)))
В такой модели у объекта спрашивают о его площади, и он отвечает
сообразно методу своего класса.

Рождение CLOS могло бы показаться знаком того, что Лисп меняется,
вступая на путь объектно-ориентированной парадигмы.  На самом деле
правильнее сказать, что Лисп, вступая на него, остаётся тем же.  Но
принципы, лежащие в основе Лиспа, не имеют названия, а
объектно-ориентированное программирование имеет, оттого и наблюдается
новая тенденция характеризовать Лисп как объектно-ориентированный.
Правильнее сказать, что Лисп - расширяемый язык, допускающий лёгкую
реализацию концепции объектно-ориентированного программирования.

Поскольку CLOS уже написана, называние Лиспа объектно-ориентированным
не ложно.  Однако такой взгляд слишком ограничен.  Да, Лисп -
объектно-ориентированный язык, но не потому, что он перенял
объектно-ориентированную модель.  Наоборот, сама модель оказывается
лишь ещё одной метаморфозой лежащих в основе Лиспа абстракций.
Доказательством этому служит CLOS, написанная на Лиспе программа,
делающая Лисп объектно-ориентированным.

Эта глава нацелена выявить связь между Лиспом и
объектно-ориентированным программированием, изучая CLOS как пример
встроенного языка.  Это также и хороший способ понять саму CLOS: в
конце концов, ничто не объясняет отличительную черту языка лучше, чем
набросок её реализации.  В разделе 7.6 так были объяснены макросы.
Подобный набросок построения объектно-ориентированных абстракций на
Лиспе дан в следующем разделе.  Он предоставляет исходную точку
описания CLOS в разделах 25.3-25.6.
