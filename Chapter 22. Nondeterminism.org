* 22  Недетерминированность
# «Индетерминизм» кажется мне проще, но переводчики AIMA выбрали «недетерминированность»

Языки программирования помогают не утонуть в деталях.  Язык Лисп хорош
тем, что сам управляется со многими из них, предоставляя программисту
выжать максимум из ограниченной способности удерживать сложное.  Эта
глава посвящена тому, как с помощью макросов можно обращаться с ещё
одним важным классом подробностей: подробностей преобразования
недетерминированного алгоритма в детерминированный.

В главе пять частей.  Первая объясняет смысл недетерминизма.  Вторая
описывает реализацию недетерминистического /выбора/ и /неудачи/ на
Scheme с использованием продолжений.  В третьей представлена версия на
Common Lisp на основе передающих продолжения макросов из 20-ой главы.
Четвёртая показывает, как понять оператор отсечения (cut) вне
зависимости от Пролога.  Последняя предлагает уточнения исходных
недетерминированных операторов.

Оператор недетерминированного выбора используется в дальнейшем при
написании ATN-компилятора в 23-ей главе и встроенного Пролога в 24-ой.

* 22.1  Общая идея

Недетерминированный алгоритм — алгоритм на основе сверхъестественного
предвидения.  Зачем говорить о них, не располагая сверхъестественными
компьютерами?  Потому что недетерминированный алгоритм можно
имитировать детерминированным.  Это особенно просто в чисто
функциональных программах (не имеющих побочных эффектов).  В них его
можно реализовать с помощью поиска с отступлением.
# Backtracking вроде переводят как возврат; я пробовал так, но выходит
# путаница с return; поэтому я переделал на «отступление»

# Нельзя всё время повторять «недетерминированность»
Эта глава посвящена симуляции неопределённости в функциональных
программах.  Располагая таким симулятором, мы рассчитываем справляться
с проблемами, разрешимыми на действительно недетерминированной машине.
Зачастую программа с сверхъестественными озарениями пишется проще
обычной, так что этот симулятор иметь в наличии хорошо.

Данный раздел очерчивает класс возможностей, предоставляемых нам
неопределённостью; следующий демонстрирует их полезность в некоторых
программах.  Примеры написаны на Scheme.  (О некоторых различиях между
Scheme и Common Lisp сказано в начале 20-ой главы.)

Недетерминированный алгоритм отличается от детерминированного
использованием специальных операторов /выбора/ и /неудачи/.  /Выбор/
принимает ограниченное множество и возвращает один элемент.  Чтобы
объяснить принцип работы /выбора/, нужно ввести понятие
вычислительного /будущего/.

Здесь /выбор/ представлен функцией =choose=, принимающей список и
возвращающей его элемент.  Для каждого элемента есть набор будущих,
принимаемых вычислением при условии выбора этого элемента.  В
следующем примере

#+begin_src scheme
(let ((x (choose '(1 2 3))))
  (if (odd? x)
      (+ x 1)
      x))
#+end_src

к моменту достижения =choose= у вычисления три возможных будущих:

1. Если =choose= возвращает 1, вычисление по ветви “то” вернёт 2.
2. Если =choose= возвращает 2, вычисление по ветви “иначе” вернёт 2.
3. Если =choose= возвращает 3, вычисление по ветви “то” вернёт 4.

В данном случае мы знаем точное будущее сразу, как только =choose=
вернёт какое-либо значение.  Вообще же каждый выбор связан с набором
возможных будущих, потому что в некоторых из них могут быть
дополнительные выборы.  К примеру

#+begin_src scheme
(let ((x (choose '(2 3))))
  (if (odd? x)
      (choose '(a b))
      x))
#+end_src

после первого выбора имеется два набора будущих:

1. Если =choose= возвращает 2, вычисление по ветви “иначе” вернёт 2.
2. Если =choose= возвращает 3, вычисление по ветви “то” разделится на
два возможных будущих, одно из которых возвращает =a=, другое — =b=.

У первого набора одно будущее, у второго — два; всего — три.

Здесь важно, что каждый из альтернативных выборов связан со своим
набором возможных будущих.  Какой из них будет возвращён?  Можно
предположить, что /выбор/ работает следующим образом:

1. Он вернёт лишь тот набор будущих, в котором хотя бы одно не
   заканчивается /неудачей/.
2. /Выбор/ из нуля альтернатив эквивалентен /неудаче/.

Так, к примеру, в:

#+begin_src scheme
(let ((x (choose '(1 2))))
  (if (odd? x)
      (fail)
      x))
#+end_src

каждый возможный выбор имеет по одному будущему.  Поскольку выбор 1
содержит вызов =fail=, может быть выбрано лишь 2.  Поэтому выражение в
целом детерминированно, всегда возвращая 2.

Однако, следующее выражение недетерминированно:

#+begin_src scheme
(let ((x (choose '(1 2))))
  (if (odd? x)
      (let ((y (choose '(a b))))
        (if (eq? y 'a)
            (fail)
            y))
      x))
#+end_src

После первого выбора, у =1= два возможных будущих и у =2= одно.  У
первого, однако, будущее детерминированно, поскольку выбор =a= вызвал
бы =fail=.  Поэтому выражение в целом может вернуть либо =b=, либо
=2=.

Наконец, однозначно следующее выражение:

#+begin_src scheme
(let ((x (choose '(1 2))))
  (if (odd? x)
      (choose '())
      x))
#+end_src

потому что выбор =1= означает последующий выбор без единого варианта.
Так что этот пример эквивалентен пред-предпоследнему.

Возможно, это ещё не стало очевидным, но мы обрели абстракцию
изумительной силы.  В недетерминированных алгоритмах можно сказать
“выбери элемент так, чтобы ничего в дальнейшем не привело к неудаче”.
Например, вот полностью корректный алгоритм для установления, есть ли
у кого-либо предок по имени Игорь:

#+BEGIN_EXAMPLE
Функция Иг(и)
  если имя(и) = “Игорь”
    вернуть и
  иначе если родители(и)
    вернуть Иг(выбрать(родители(и)))
  иначе неудача
#+END_EXAMPLE

Оператор /неудачи/ используется, чтобы повлиять на значение,
возвращаемое /выбором/.  Если встречается /неудача/, /выбор/ сработал
неправильно.  Но он по определению выбирает правильно.  Поэтому всё,
что нам нужно, чтобы предотвратить вычисление определённой ветви -
поместить где-либо в ней /неудачу/.  Так, рекурсивно проходя
поколения предков, функция Иг на каждом шаге выбирает ветвь, ведущую к
Игорю, угадывая, по отцовской или материнской линии идти.

Это как если бы программа могла указать /выбору/ взять один из
альтернативных элементов, использовать возвращённое значение сколько
понадобится, и ретроспективно решить, используя /неудачу/ как запрет,
что /выбору/ нужно было взять.  И вуаля, оказывается, что /выбор/ его
и взял.  Именно в этом смысле говорят, что /выбор/ обладает
предвидением.

На деле, конечно, /выбор/ не сверхъестественен.  Всякая его реализация
эмулирует нужное угадывание отступлением от ошибок, подобно мыши в
лабиринте.  Но всё это отступление - скрываемо.  Располагая лишь
какими-либо /выбором/ и /неудачей/, уже можно писать алгоритмы подобно
вышеприведённому, как если бы действительно возможно было угадать, по
пути какого из предков следовать.  Используя /выбор/, можно получить
алгоритм поиска в проблемной области, написав лишь алгоритм её обхода.

* 22.2  Поиск

Многие классические проблемы можно описать как проблемы поиска, и
недетерминизм часто оказывается для них полезной абстракцией.
Допустим, =nodes= содержит список вершин в дереве, а функция =(kids
n)= возвращает наследников вершины =n=, либо =#f= в их отсутствие.  Мы
хотим определить функцию =(descent n1 n2)=, возвращающую список вершин
на каком либо пути между =n1= и её наследником =n2=.  Рисунок 22.1
представляет детерминированный вариант этой функции.

#+SRCNAME: Рисунок 22.1: Детерминированный поиск по дереву
#+BEGIN_SRC scheme
(define (descent n1 n2)
  (if (eq? n1 n2)
      (list n2)
      (let ((p (try-paths (kids n1) n2)))
        (if p (cons n1 p) #f))))

(define (try-paths ns n2)
  (if (null? ns)
      #f
      (or (descent (car ns) n2)
          (try-paths (cdr ns) n2))))
#+END_SRC

Недетерминированность позволяет программисту не заботится о способе
поиска пути.  Можно просто сказать /выбору/ найти вершину =n= такую,
чтобы от неё до цели был путь.  Этот вариант =descent=, изображённый
на рисунке 22.2, проще.

#+SRCNAME: Рисунок 22.2: Недетерминированный поиск по дереву
#+BEGIN_SRC scheme
(define (descent n1 n2)
  (cond ((eq? n1 n2) (list n2))
        ((null? (kids n1)) (fail))
        (else (cons n1 (descent (choose (kids n1)) n2)))))
#+END_SRC

Данный вариант не занимается явным поиском вершины на правильном пути.
Он написан в предположении, что =choose= выбирает желаемую =n=.
Привыкший лишь к детерминированным программам может и не заметить, что
=choose= словно /угадывает/, какая =n= войдёт в удачное вычисление.

Возможно, ещё убедительнее возможности /выбора/ продемонстрирует
угадывание при вызове функций.  На рисунке 22.3 пара функций угадывает
два числа, суммирующихся к заданному.  Первая, =two-numbers=,
недетерминированно выбирает два числа и возвращает их в виде списка.
Вторая, =parlor-trick=, обращается за ним к первой.  Отметим, что
=two-numbers= не знает о заданном числе.

#+SRCNAME: Рисунок 22.3: Подпрограмма выбора
#+BEGIN_SRC scheme
(define (two-numbers)
  (list (choose '(0 1 2 3 4 5))
        (choose '(0 1 2 3 4 5))))

(define (parlor-trick sum)
  (let ((nums (two-numbers)))
    (if (= (apply + nums) sum)
        '(the sum of ,@nums)
        (fail))))
#+END_SRC

Если два угаданных /выбором/ числа не образуют требуемой суммы,
вычисление не удаётся.  Можно считать, что =choose= избегает неудачных
вычислительных путей, если есть хоть один удачный.  Предположительно,
при задании числа в правильном диапазоне, =choose= угадывает верно;
так и происходит:

#+BEGIN_SRC scheme
> (parlor-trick 7)
(THE SUM OF 2 5)
#+END_SRC

В случае простого поиска, встроенная функция =find-if= из Common Lisp
сработает не хуже.  Где же преимущество недетерминированного выбора?
Почему не пройти просто в цикле по списку альтернатив в поиске
желаемого элемента?  Ключевое отличие /выбора/ от обыкновенной
итерации в том, что его область действия по отношению к /неудаче/ не
ограничена.  Недетерминированный /выбор/ смотрит сколь угодно далеко в
будущее; если в будущем случится что-либо, аннулирующее прошлый
/выбор/, можно считать, что он и не совершался.  Как было показано на
примере =parlor-trick=, оператор неудачи работает даже после возврата
из функции, содержащей /выбор/.

Такие же неудачи случаются и при поиске в Прологе.
Недетерминированность в нём полезна, поскольку одна из характерных
особенностей этого языка — возможность получать ответы на запросы по
одному за раз.  Не возвращая все удовлетворяющие ответы сразу, Пролог
справляется с рекурсивными правилами, которые иначе бы выдавали
бесконечное множество ответов.

Вашим первым впечатлением от =descent=, возможно, как и от сортировки
слиянием, был вопрос: где же выполняется работа?  Как и при сортировке
слиянием, она происходит неявно, но всё же происходит.  В разделе 22.3
описана реализация /выбора/, превращающая все вышеприведённые примеры
в рабочие программы.

Эти примеры иллюстрируют значение недетерминизма как абстракции.
Лучшие абстракции программирования сокращают не только код, но и
мысль.  В теории автоматов некоторые доказательства затруднительно
даже понять без обращения к недетерминизму.  Язык, допускающий
недетерминизм, вероятно, предоставляет программистам сравнимое
преимущество.
